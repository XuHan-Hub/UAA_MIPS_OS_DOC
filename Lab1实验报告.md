# Lab1实验报告## 实验思考题###1. 深夜，小明在做操作系统实验。困意一阵阵袭来，小明睡倒在了键盘上。等到小明早上醒来的时候，他惊恐地发现，他把一个重要的代码文件 printf.c 删除掉了。苦恼的小明向你求助，你该怎样帮他把代码文件恢复呢？答：第一种：14061036@ubuntu:~/14061036-lab/lib$ git status	# On branch Test	# Changes not staged for commit:	#   (use "git add/rm <file>..." to update what will be committed)	#   (use "git checkout -- <file>..." to discard changes in working directory)	#       deleted:    print.cno changes added to commit (use "git add" and/or "git commit -a")14061036@ubuntu:~/14061036-lab/lib$ git checkout -- print.c####文件恢复第二种：14061036@ubuntu:~/14061036-lab/lib$ git status	# On branch Test	# Changes to be committed:	#   (use "git reset HEAD <file>..." to unstage)	#       deleted:    print.c14061036@ubuntu:~/14061036-lab/lib$ git reset HEAD print.cUnstaged changes after reset:D       lib/print.c14061036@ubuntu:~/14061036-lab/lib$ git status	# On branch Test	# Changes not staged for commit:	#   (use "git add/rm <file>..." to update what will be committed)	#   (use "git checkout -- <file>..." to discard changes in working directory)	#       deleted:    print.cno changes added to commit (use "git add" and/or "git commit -a")14061036@ubuntu:~/14061036-lab/lib$ git checkout -- print.c####文件恢复###2. 正在小明苦恼的时候，小红主动请缨帮小明解决问题。小红很爽快地在键盘 上敲下了 git rm printf.c，这下事情更复杂了，现在你又该如何处理才能弥补小红的过错呢？答：同第一问第二种。###3. 处理完代码文件，你正打算去找小明说他的文件已经恢复了，但突然发现小明的仓库里有一个叫 Tucao.txt，你好奇地打开一看，发现是吐槽操作系统实验的，且该文件已经被添加到暂存区了，面对这样的情况，你该如何设置才能使 Tucao.txt 在不从工作区删除的情况下不会被 git commit 指令提交到版本库？ 答：git rm --cached tucao.txt或者git reset HEAD tucao.txt可以从暂存区删除Tucao.txt，以防万一再被跟踪，在.gitignore中设置忽Tucao.txt。###4. 克隆时所有分支均被克隆，但只有 HEAD 指向的分支被检出。答：对的，.git/refs/remote中有信息，git branch -r可以明确看出。参考：《git权威指南》###5. 克隆出的工作区中执行 git log、 git status、 git checkout、 git commit 等操作不会去访问远程版本库。答：对的，都是对当前本地版本库，通过指导书中对暂存区的解释可得之。###6. 克隆时只有远程版本库 HEAD 指向的分支被克隆。答：错误的，所有分支都被克隆在.git/refs/remote中有信息，通过git show-ref可以看到全部本地引用。###7. 克隆后工作区的默认分支处于 master 分支答：第一次客隆完，我们所处master分支。## 实验难点###1.  指导书中在进行操作前的内容，不是很好理解，比如2.2.3.但做完lab1，才明白仿真器，更好的理解了这些。###2.  Makefile文件基本也是实验完后能更好地理解，同时，我加入了      all: $(modules) vmlinux             /OSLAB/gxemul -E testmips -C R3000 -M 64 ./gxemul/vmlinux###使得make后能快速启动，这在我第一遍实在是不太明白。###3. 在实战printf中，难度不小，瞪眼看了1天，不如放到codeblock中跑一边，对照平常我们所写的printf函数。 难度主要在理解printf的格式放到printf(“%.........”,x);就一下明白了，修改代码，十分依赖编译器，在vim中编辑不会调试，语法错误严重，使得在codeblock编辑在复制到vim中。###4. Git要学好挺难的，非常的庞大. 比较常用的：git log,git status,git –help,git pull oigin ….,git add和git commit, 像是git status中都会有提示，怎么处理文件。 分支常用： git checkout，git branch -a 因为搞乱过分支，时光机和强制提交修改忽略文件，查找文件不同，融合等等也使用到了。##体会与感想 + Lab1的实验总体感觉偏容易，实验的完成可能不超过24小时。其余的像熟悉操作环境，使用各种命令去操作，vim，git都花费了大量的时间，尤其在最开始配置自己的实验环境，因为不清楚有远程的实验环境，自己怎么也配置不出来，下了恩多的ubuntu版本，简直绝望。+ 从Lets hack the kernel!开始明白了我们应该区分干什么，为啥要这么干，但起初开始还真是一头雾水，但如今也做完lab2后再回过头看，发现能理解了更多。+ Git不得不提，我练习他的时间仅次于配置环境，通过 git pro，和git权威指南对git 和他的基本方法有一定的了解和实践，在实用角度有很深的体会。本次实验都不算难，不是很理解也是可以做出来的，我确实是做到现在才明白了好多，之所以快速的去做试验，是因为我想看看后面有没有能解决我前面的问题的东西，事实上，这是非常有必要的。##指导书反馈+  我觉得指导书编的内容很丰富，但是初次难道，看的过程实在辛苦像是现在回过头看，真的好不错，希望能在指导书中在后面能过关联前面，比如做完lab1回顾一下这些，不能做完就看下一个试验去了。+ 再像启动完lab1内核，后可以让大家改写Makefile文件使得内核快速启动，同时也更深的理解了Makefile格式。+ Git的clone实验好想做一做，但怕毁了现有的，不敢做啊，希望提供环境(思考题只通过看书啦，没实际操作，好不爽2333)+ 有些指令不太对，像是时光机中git reset --hard 是2个-；可能是版本不对吧。+ 更多的语法错误因为编写希望有一些提示，这是我舍友说的git push origin/lab1这是错误的，没有中间的/。还有写lds中要注意语法。 + 我觉得以后以后实验可以提前开实验环境，让大家提前练练指令。##残留难点+ 在写start.S需要设置sp，但是用那个指令更好呢，lui，li（我在lab2中看到），ori；j main，还是jar main，还是都一样?+ 在写lds文件中把内核加载到0x8001000，.bss和.data段也是接着text段吗，在lab2中起始为8020000，.bss和.data段在8040000，这是为啥。