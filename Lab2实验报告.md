# Lab2实验报告## 实验思考题###Thinking 2.1 1.举例来说，假设需要定义这样一个宏：		#define DOSOMETHING()\      		 foo1();\ 		 foo2();这个宏的本意是，当调用DOSOMETHING()时，函数foo1()和foo2()都会被调用。但是如果这么写：		if(a]]>0)			 		DOSOMETHING();因为宏在预处理的时候会直接被展开，实际上写的代码是这个样子的：		if(a]]>0)		foo1();		foo2();问题:因为无论a是否大于0，foo2()都会被执行，导致程序出错。那么仅仅使用{}将foo1()和foo2()包起来是不行的，因为写代码的时候都习惯在语句右面加上分号，如果在宏中使用{}，代码里就相当于这样写了：“{...};”，展开后就是这个样子：	if(a]]>0){		foo1();		 foo2();	};这样甚至不会编译通过。所以，很多人才采用了do{...}while(0); 这样，宏被展开后，才会保留初始的语义。			#define DOSOMETHING() \		do{ \			 foo1();\			 foo2();		}while(0);		if(a]]>0)			DOSOMETHING();2、避免使用goto对程序流进行统一的控制：有些函数中，在函数return之前我们经常会进行一些收尾的工作，比如free掉一块函数开始malloc的内存，goto一直都是一个比较简便的方法：	int foo(){		somestruct* ptr = malloc(...);		dosomething...;		if(error){			goto END;		}		dosomething...;	END: 		free(ptr);		return 0;	}由于goto不符合软件工程的结构化，而且有可能使得代码难懂，所以很多人都不倡导使用，那这个时候就可以用do{}while(0)来进行统一的管理:		int foo(){		somestruct* ptr = malloc(...);		do{			dosomething...;			if(error){				break;			}			dosomething...;		}while(0);		free(ptr);		return 0;	}这里将函数主体使用do()while(0)包含起来，使用break来代替goto，后续的处理工作在while之后，就能够达到同样的效果。3.避免空宏引起的warning内核中由于不同架构的限制，很多时候会用到空宏，在编译的时候，空宏会给出warning，为了避免这样的warning，就可以使用do{}while(0)来定义空宏:		#define EMPTYMICRO 			do{}while(0)###Thinking 2.2 答：Win2k内核中4M空间的起始位置也就是第一个二级页表对应着页目录的第一个页目录项，同时，由于1024个页表项和 4G 地址空间是线性映射，0xC0000000 这一地址对应的应该是第（0xC0000000 >> 12）个页表项，这个页表项也就是第一个页目录项。一个页表项32位，占用4个字节的内存，因此，其相对于页表起始地址0xC000000的偏移为(0xC0000000 >> 12）* 4 = 0x00300000，页目录的起始地址0xC0000000 + 0x00300000 = 0xC0300000.###Thinking 2.3 将CP0_ENTRYHI寄存器中的值（VPN2 和ASID）保存到27号寄存器，再将a0寄存器中的PTE_ADDR(va) | GET_ENV_ASID(curenv->env_id)（清除有效位的虚拟地址或运算上但前进程id的ASID位）保存到CP0_ENTRYHI寄存器。tlbp搜索虚拟页号及ASID跟当前CP0_ENTRYHI中的值相匹配的TLB项，并把该项的索引保存到CP0_INDEX寄存器。若没有找到匹配则CP0_INDEX寄存器的第31位置1——这样看上去像个负值，因而易于检测。btlz CP0_INDEX寄存器中的值小于0为进入NOFOUND，并将恢复CP0_ENTRYHI本来的值（在查找过程中，ASID域会发生改变），之后跳出函数如果CP0_INDEX寄存器中的值大于等于0，重置CP0_ ENTRYHI和CP0_ ENTRYLO0寄存器用tlbwi写入新的tlb##实验难点###代码阅读障碍+ 指针使用不熟悉：*p、**p、&p、C代码中出现的指针存储的全部是虚拟地址、只有页表中存储的是物理地址+ 变量名不理解英文不好：比如：（现在再看好像都很简单的样子）pgtable页表、va虚拟地址、pgdir页目录，函数名pa2kva啥的+ 分布在各种地方的函数方法：mmu.h、pmap.h、printf.h、env.h、error.h、types.h###代码阅读障碍+ 地址转换过程(不明白就真不明白、明白了估计就不会忘了）+ 物理内存与虚拟内存的区分，混在了一起，通过我逐行读码才弄明白+ Tlb那段汇编需要看See MIPS Run Linux##体会与感想 + 这个实验比实验一难度大了不知道几倍，但是我也是在一个星期照着各种资料各种源码马虎的完成了第一次。因为什么都不明白，只能想往下做，最后做完只知道了个大概，这第一次做lab2可能花费了4-5天，在oo写博客的那周。测试通过很高兴，但后来等大家做完lab1，发布了改版的代码，更加的详细，注释也异常的清晰，我就重新做了一遍lab2对照着新的注释和之前写的代码，彻彻底底的大改了一遍，这一遍我能懂了50%了，我知道之后我必须还得再做一遍。就在清明节之后的几天里，我这回静下心，认认真真从头逐行逐词的阅读这些代码。把每个地址打印，对比手动计算其中的过程，又发现了第二次中的错误。而且能明白75%了，阅读的过程也真是痛苦，但看懂的喜悦也真是不错。指针这种东西也因为这次lab2很好的掌握了，一直以来最可怕的指针也不过如此。##指导书反馈+  我觉得在tlb汇编函数那段增加更多的内容，虽然不清楚之后会不会讲到。比如：增加See MIPS Run Linux的第六章推荐阅读